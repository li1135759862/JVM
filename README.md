# JVM 入门

### 运行时数据区域

*   程序计数器（线程私有）:当前线程执行字节码的信号指示器，通过改变计数器来选取下一条字节码指令，分支，循环，跳转，异常处理，线程回复等功能。
*   Java虚拟机栈（线程私有）：每个方法在执行都会建立栈帧，用于储存局部变量表，操作数栈，动态链接，方法出口等信息。（执行java方法）
*   局部变量表：储存基本类型以及对象引用类型，其中long和double占用两个局部变量空间
*   本地方法栈：和java虚拟栈类型,执行native方法服务。（有些虚拟机吧本地方法区和java虚拟机栈直接合并）
*   java堆:几乎所有的对象实例都存放在堆中，但是随着JTL编译器的发展逃逸分析技术的成熟，并非“绝对”了，堆可以细分为：eden空间，from survivor空间，to survivor空间
*   方法区（俗称永久代）：和java堆一样，是各个线程共享的内存局域，它用于存储已经被虚拟机加载的类信息，常亮，静态变量等。
*   运行时常量池：它是方法区的一部分，class文件除了问类的版本，字段，方法，接口等信息，还有一项是常量池，用于存放编译期生成的各种字面量和符号应用。这部分内容将在类加载后进去方法区的运行时常量池中存放。直接内存：NIO，JDK1.4新加入的类，应用了一种通道和缓存区的IO方式，可以使用native函数库直接向系统申请空间，避免在java堆和native堆中来回复制数据，这些空间不归属于JVM管理。

### 对象定位访问

#### 对象：对象头 ，实际数据 ，对其填充
* 对象头第一部分用于储存对象自身的运行时数据（Mark word）：如 hashCode，GC分代年龄，锁的状态，线程持有的锁，偏向锁线程的ID，偏向时间戳等
* 对象头另外一部分是类型指针，即使对象指向它的元素的指针。通过指针确定类信息对象还有一块用于记录数组大小

### 对象

#### 主流访问方式
>   使用句柄池（类信息和对象信息的具体地址信息）
>>  * 优点：对象移动只需要修改句柄池，不需要修改对象本身.如GC
>>  * 缺点：增加一次指针

>   直接指针	（java对象的布局就必须考虑如何安放）
>>  * 优点：访问速度快，节省了一次指针定位的时间开销。
>>  * 缺点：修改时，需要修改对象本身

## GC

### 判断对象是否存货
#### 引用计数算法  
```
对象被引用一次，计算器就加1，引用失效就减1
缺点：很难解决对象相互依赖的问题
如 A>B B>A,计算器不为0，无法回收
```
#### 可达性分析法
```
当对象没有任何引用链相连时，就证明此对象不可达。
```
### roots可选对象

*   虚拟机栈中应用的对象
*   方法区中类静态属性引用的对象
*   方法区中常量引用的对象
*   本地方法栈中JNI（Native方法）引用对象
#### 引用类型（强度一次递减）
```
强引用 :类似 Object obj=new Object()
软引用 :描述一些还有用但是并非必须的接口，在系统将要发生内存溢出异常之前，这些对象列入进行回收的范围之中进行第二次回收，JDK1.2之后，提供softReference接口
弱引用：描述非必须对象，比软引用更弱，存活到下次GC之前。接口weakReference
虚引用:一个对象是否有虚引用的存在，完全不会对其生存构成影响，也无法通过虚引用获取一个对象实例。
设置虚引用的目的。就是当对象被回收时收到一个系统的通知。
```
#### 无用的类条件：
```
1，该类所有的实例都已经被回收
2，加载该类的ClassLoader已经被回收
3，该类对应的java.lang.Class对象没有任何地方引用，无法在任何地方通过反射访问该类
```
#### 垃圾回收算法
```
1，标记清除算法
优点：实现简单
缺点：效率低，空间碎片太多
2，复制算法
优点：简单，运行高效，不会产生空间碎片
缺点:（1，需要额外的空间存储对象（GC时存活的对象） 存储比例：8：1：1
（2，对象存活较多时，效率低下
3，标记整理发（先标记清理，在移动对象整理磁盘）
4，分代收集算法
根据年代不同，进行最适合的收集算法。在新生代使用复制算法，在老年代使用”标记清理“或者“标记整理”
```

#### 安全点
```
是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定，比如记录OopMap的状态，从而确定GC Root的信息，使JVM可以安全的进行一些操作，比如开始GC。
1. 循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)
2. 方法返回前
3. 调用方法的call之后
4. 抛出异常的位置
让所有线程处于安全点的方法：
1，抢先式中断：让所有线程中断，没有处于安全点就让线程在执行，执行到了安全点再中断。
2，主动式中断：设置一个标志，让线程自己轮训这个标志，发现中断标志为真就自己中断。
```
####    安全区域 Safe Region（一些无法响应JVM的中断请求设置的区域）
```
线程处于sleep或者block状态，线程无法响应JVM的请求，这种情况就需要安全区域，
安全区域只在一段代码之中，引用关系不会发生变化，在这个区域中的任意地方，开始GC都是安全的
```
####    垃圾收集器
```
younng generation 新生代收集器
1.serial  :单线程，停止所有线程
适合单CUP，新生代复制算法，老年代标记整理算法
2.parnew：多线程：停止所有线程
适合多线程，新生代复制算法，老年代标记整理算法
3.parallel  scavengc：多线程，不停止线程，
该收集器关注的是一个可控的吞吐量，而CMS关注的是最短停止时间
吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
并不是停顿时间调的越小越好，因为时间越短，收集的垃圾就越少，吞吐量下降，GC频繁
```
####    Tenured generation 老年代收集器
```
1.cms ：多线程
以“最短回收停顿时间”为目标的收集器
（1）初始标记：停止所有线程
（2）并发标记：
（3）重新标记：停止所有线程
（4）并发清除
缺点：1，多线程占用系统资源，导致吞吐量下降
    2.无法处理浮动垃圾（产生在标记之后），可能导致再次GC
     3.标记清理导致过多碎片空间
2.serial old：单线程，停止所有线程
新生代复制算法，老年代标记整理算法
3.parallel old ：多线程，停止所有线程
新生代复制算法，老年代标记整理算法，”吞吐量优先“收集器
```
####    GI
```
1，串行并发
2，分代收集
3，空间整合
4，可预测的停顿时间（通过多块Region区域实现，通过维护Region来计算时间），通过使用remembered set来记录成活的对象，避免全局Region进行扫描
收集器共有的特点
标记清理算法：
优点：简单，效率高
缺点：产生大量碎片空间
标记整理算法：
优点：不会产生空间碎片
缺点：需要额外空间，需要对象移动消耗时间
单线程GC：速率慢
多线程GC:快速，需要额外的系统资源
```
####    年代的判断：
```
计数器：第一：当对象进过一次GC依然存活，就加1，--XX:MaxTenuringThreshold=2 参数可以设置老年代的年龄阀门。
动态判断：第二：当在Survivor空间中相同的年龄对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进去老年代。
当年轻代GC时，存活的对象较多，就是用Survivor空间进行担保，当Survivor空间不足时，就是用老年代进行担保，依然不足，就在次进行Full GC
```




